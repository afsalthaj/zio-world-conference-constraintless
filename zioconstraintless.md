footer: @zioworld

# Constraintless

---

## Famous Example

```scala

enum Expr[A] {
  case IntExpr(expr: Int) extends Expr[Int]
  case DoubleExpr(expr: Double) extends Expr[Double]
  case Sum[A](left: Expr[A], right: Expr[A]) extends Expr[A]
  case Zip[A, B](left: Expr[A], right: Expr[B]) extends Expr[(A, B)]
}

```
---
## Expr Usage

```scala
  val myExpr =
    Sum(IntExpr(1), IntExpr(2))

  val complexExpr =
    Sum(
      Zip(myExpr, myExpr), 
      Zip(IntExpr(3), IntExpr(4))
    )
```

---

## Compile

```scala
  def compile[A](expr: Expr[A]): A =
    expr match {
      case Expr.IntExpr(int)       => int
      case Expr.DoubleExpr(double) => double
      case Expr.Sum(left, right)   => compile(left) + ??? // hmm, is compile(left) a tuple or ???
      case Expr.Zip(left, right)   => (compile(left), compile(right))
    }
```

---

## Compile

The core of the problem is we are dealing with unknown types.

May be we can solve through typeclass

---
## Num typeclass

```scala
  trait Num[A] {
    def add(l: A, r: A): A
  }

  object Num {
    given Num[Int] = (l: Int, r: Int) => l + r
    given Num[Double] = (l: Double, r: Double) => l + r
    given numTuple[A, B](using ev1: Num[A], ev2: Num[B]): Num[(A, B)] = ...
  }

```

---

## Typeclass

```scala


 // Conceptually wrong but it complies and works for many cases :)
 def compile[A](expr: Expr[A])(implicit ev: Num[A]): A = 
    expr match {
      case Expr.IntExpr(expr) => expr
      case Expr.DoubleExpr(expr) => expr
      case Expr.Sum(left, right) => ev.add(compile(left)(ev), compile(right)(ev))
      case zip: Expr.Zip[a, b] => 
       val ev_ = ev.asInstanceOf[Num[A]]
      (compile(zip.left)(ev_), compile(zip.right)(ev_))
    }

 compile(sum(zip(int(1), int(2)), zip(int(2), int(3))) // works
 compile(zip(sum(int(1), int(2)), sum(int(2), int(3))) // runtime exception

```


---
 
## How about constraints at the point of definition ?
 

---

## Example

```scala

enum Expr[A] {
  case IntExpr(expr: Int) extends Expr[Int]
  case DoubleExpr(expr: Double) extends Expr[Double]
  case Sum[A](left: Expr[A], right: Expr[A])(using val ev1: Num[A]) extends Expr[A]
  case Zip[A, B](left: Expr[A], right: Expr[B]) extends Expr[(A, B)]
}

```

---

## And that compiles

```scala

  def compile[A](expr: Expr[A]): A =
    expr match {
      case Expr.IntExpr(expr) => expr
      case Expr.DoubleExpr(expr) => expr
      case sum @ Expr.Sum(left, right) => sum.ev1.add(compile(left), compile(right))
      case zip: Expr.Zip[a, b] => (compile(zip.left), compile(zip.right))
    }

```

---

## But ?

The language knows the executor details.
Num was really an executor detail.

---

## In other words

It should depend on the type of executor whether or not we need an instance of typeclass(es)

---

## Example

We never use the `Num` typeclass in this compiler

```scala
def compile[A](expr: Expr[A]): String =
  expr match {
    case Expr.IntExpr(expr) => s"${expr}"
    case Expr.DoubleExpr(expr) => s"${expr}"
    case Expr.Sum(left, right) => s"${compile(left)} + ${compile(right)}"
    case zip: Expr.Zip[a, b] => s"(${compile(zip.left)}, ${compile(zip.right)})"
}

println(compile(complexExpr))
// (1 + 2, 1 + 2) + (3, 4)

```
---


### http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf

> The key principle that underpins our idea is that implementation- specific constraints should be imposed at the point of use of a data type, not at the point of definition, 

>i.e. it embodies the established principle that an interface should be separated from its implementation(s).


---
## ZIO Constraintless 
 
Implementation based on a Haskell paper

```scala

http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf

(Will Jones, Tony Field & Tristan Allwood)
``` 



---
## Core idea

Essentially, we need to be able to define a compiler that depends on one or more type classes to do something with the types.


---

## Core idea


We need any types generated by the program at any point, to have an instance of a typeclass.


---

## Core idea

Zio-constraintless has `Instances[_, _]` 


`Instances[Num, As]` says that
all the types in `As <: TypeList` 
has an instance of `typeclass` `Num`


---

## Core idea

This implies, we need to have an idea of all possible types that the program generates.


---
## Redefine our Expr

```scala

enum Expr[As <: TypeList, A]


```
---
## Terms

```scala

  case IntExpr[As <: TypeList](expr: Int) extends Expr[As, Int]
  case DoubleExpr[As <: TypeList](expr: Double) extends Expr[As, Double]

```

---
## Terms


```scala

  // Interestingly
  case Sum[As <: TypeList, A](
   left: Expr[As, A], 
   right: Expr[As, A]
  )(using val elem: A IsElementOf As) extends Expr[As, A]
```


---

## My allowed types

```scala
 // Later
  type AllowedTypes = Int :: Double :: (Int, Int) :: (Int, Double) :: End
```

--- 
## My Allowed types (Note)

```scala
// In scala3, it gets even better
type Prim = Int | Double
type AllowedTypes = Prim :: (Prim, Prim) :: (Prim, Prim, Prim) :: End

// Replacing IntExpr & DoubleExpr with
case Primitive[As <: TypeList, A <: Prim](
  expr: A
)(using val elem: Prim IsElementOf As) extends Expr[As, Prim]


```

---

## My Allowed types (Note)

```scala

// Infact this is possible too
type AllowedTypes[A] = A :: (A, A) :: (A, A, A) :: End



```
---

## Helpers


```scala
def sum[A](
  a: Expr[AllowedTypes, A], 
  b: Expr[AllowedTypes, A]
)(implicit elem: A IsElementOf AllowedTypes) =
  Sum(a, b)


```

---

## Helpers


```scala

  def zip[A, B](
   a: Expr[AllowedTypes, A], 
   b: Expr[AllowedTypes, B]
  )(implicit ev: A IsElementOf AllowedTypes, ev2: B IsElementOf AllowedTypes) =
    Zip(a, b)

```

---

## Original program

```scala

  val myExpr =
    sum(IntExpr(1), IntExpr(2))

  val complexExpr =
    sum(zip(myExpr, myExpr), zip(IntExpr(3), IntExpr(4)))
```

---

## Compiler


```scala

  def compile[As <: TypeList, A](
   expr: Expr[As, A]
  )(implicit instances: Instances[Num, As]): A =
    expr match {
      case sum @ Expr.Sum(left, right) =>
        def add[B](a: B, b: B): Num[B] => B =
          _.add(a, b)

        instances.withInstance(
          add(compile(left), compile(right))
        )(sum.elem)
    }


```

---

# Another example

```scala

  enum Query[A] {
    case ReadDb[A](input: String) extends Query[A]
    case ReadCache[A](input: String) extends Query[A]
    case ReadAPI[A](input: String) extends Query[A]
    case Map[A, B](query: Query[A], f: A => B) extends Query[B]
    case FlatMap[A, B](query: Query[A], f: A => Query[B]) extends Query[B]
  }

```
---

## Compiling the query

```scala

def compiler[As <: TypeList](query: Query[A])(implicit 
  sqlDec: Instances[SqlDecoder, As], 
  jsonDec: Instances[JsonDecoder, As]
): Task[A] = {
  case db @ ReadDb(str)     => sqlDec.withInstance(...)(db.elem)
  case api @ ReadAPI(str)   => jsonDec.withInstance(...)(api.elem)
  case FlatMap(query, f) => loop(query).flatMap(a => loop(f(a)))
  case Map(query, f)     => loop(query).map(f)
}
```

---
## Summary

* We have a Program that's independent of type classes
* Program talks about `As <: TypeList` 
* Every possible types within the program should be an element of `As`
* At the compiler, we can look up the typeclass for each type from `Instances[TypeClass, As]`.

---


## When to use / examples

* Applicable for advanced libraries that rely on initial encoding.
  Currently used in ```zio-schema```
* Application codebase that deals with things like execution plan and multiple datasources, and its read/write.

---

## THANKS! 

https://twitter.com/afsalt2

---