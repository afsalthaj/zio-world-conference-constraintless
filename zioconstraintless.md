footer: Â© zioworld
slidenumbers: true

# Constraintless

---

## Famous Example

```scala

enum Expr[A] {
  case IntExpr(expr: Int) extends Expr[Int]
  case DoubleExpr(expr: Double) extends Expr[Double]
  case Sum[A](left: Expr[A], right: Expr[A]) extends Expr[A]
  case Zip[A, B](left: Expr[A], right: Expr[B]) extends Expr[(A, B)]
}

```
---
## Expr Usage

```scala
  val myExpr =
    Sum(IntExpr(1), IntExpr(2))

  val complexExpr =
    Sum(
      Zip(myExpr, myExpr), 
      Zip(IntExpr(3), IntExpr(4))
    )
```

---

## Compile

```scala
  def compile[A](expr: Expr[A]): A =
    expr match {
      case Expr.IntExpr(expr)    => expr
      case Expr.DoubleExpr(expr) => expr
      case Expr.Sum(left, right) => compile(left) + ??? // hmm, is compile(left) a tuple or ???
      case Expr.Zip(left, right) => (compile(left), compile(right))
    }
```

---

## Compile

The core of the problem is we are dealing with unknown types.

May be we can solve through typeclass

---
## Num typeclass

```scala
  trait Num[A] {
    def add(l: A, r: A): A
  }

  object Num {
    given Num[Int] = (l: Int, r: Int) => l + r
    given Num[Double] = (l: Double, r: Double) => l + r
    given numTuple[A, B](using ev1: Num[A], ev2: Num[B]): Num[(A, B)] = ...
  }

```

---

## Typeclass

```scala


 // Conceptually wrong
 def compile[A](expr: Expr[A])(implicit ev: Num[A]): A = 
    expr match {
      case Expr.IntExpr(expr) => expr
      case Expr.DoubleExpr(expr) => expr
      case Expr.Sum(left, right) => ev.add(compile(left)(ev), compile(right)(ev))
      case zip: Expr.Zip[a, b] => (compile(zip.left)(ev), compile(zip.right)(ev)) // Compile Error
    }

 compile(complexExpr)

```


---
 
## How about constraints at the point of definition ?
 

---

## Example

```scala

sealed trait Expr[A]

object Expr {
  case class IntExpr(expr: Int) extends Expr[Int]
  case class DoubleExpr(expr: Double) extends Expr[Double]
  case class Sum[A](left: Expr[A], right: Expr[A])(implicit val ev1: Num[A]) extends Expr[A]
  case class Zip[A, B](left: Expr[A], right: Expr[B])(implicit val ev1: Num[A], ev2: Num[B]) extends Expr[(A, B)]
}

```

---

## And that compiles

```scala

  def compile[A](expr: Expr[A]): A =
    expr match {
      case Expr.IntExpr(expr) => expr
      case Expr.DoubleExpr(expr) => expr
      case sum @ Expr.Sum(left, right) => sum.ev1.add(compile(left), compile(right))
      case zip: Expr.Zip[a, b] => (compile(zip.left), compile(zip.right))
    }

```

---

## But ?

The language knows the executor details.
Num was really an executor detail.

---

## In other words

It should depend on the type of executor whether or not we need an instance of typeclass(es)

---

## Example

We never use the `Num` typeclass in this compiler

```scala
def compile[A](expr: Expr[A]): String =
  expr match {
    case Expr.IntExpr(expr) => s"${expr}"
    case Expr.DoubleExpr(expr) => s"${expr}"
    case Expr.Sum(left, right) => s"${compile(left)} + ${compile(right)}"
    case zip: Expr.Zip[a, b] => s"(${compile(zip.left)}, ${compile(zip.right)})"
}

```
---


### http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf

> The key principle that underpins our idea is that implementation- specific constraints should be imposed at the point of use of a data type, not at the point of definition, 

>i.e. it embodies the established principle that an interface should be separated from its implementation(s).


---
## ZIO Constraintless 

Based on Haskell paper, http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf

---
## Core idea

Essentially, we need to be able to define a compiler that depends on one or more type classes to do something with the types.


---

## Core idea


We need every type generated by the program (list of types) at any point, to have an instance of that typeclass.


---

## Core idea

Zio-constraintless has something called `Instances[_, _]` 


`Instances[Num, As]` indicates that
all types (represented as a list `As`) has an instance of `typeclass` `Num`


---

## Core idea

This implies, we need to have a prior idea of possible types that can be generated by a program.

This is something we know already even when we don't use Constraintless.


---

## Summary of Constraintless

```scala

TypeClass itself. // In this case `Num`
TypeList (list of types that your program can ever generate)


```

---
## Redefine our Expr

```scala

sealed trait Expr[As <: TypeList, A]


```
---
## Terms

```scala

  case class IntExpr[As <: TypeList](expr: Int) extends Expr[As, Int]

```

---

## Terms

```scala

  case class DoubleExpr[As <: TypeList](expr: Double) extends Expr[As, Double]

```

---
## Terms


```scala

  // Interestingly
  case class Sum[As <: TypeList, A](
   left: Expr[As, A], 
   right: Expr[As, A]
  )(implicit val elem: A IsElementOf As) extends Expr[As, A]
```


---
## Terms

```scala

  case class Zip[As <: TypeList, A, B](
   left: Expr[As, A], 
   right: Expr[As, B]
  )(implicit val ev: A IsElementOf As, ev2: B IsElementOf As) extends Expr[As, (A, B)]

```

---
## My allowed types

```scala
  type AllowedTypes = Int :: Double :: (Int, Int) :: (Int, Double) :: End
```


---
## My allowed types

```scala
  type AllowedTypes = Int :: Double :: (Int, Int) :: (Int, Double) :: End
```

--- 
## My Allowed types (Note)

```scala
// In scala3, it gets even better

type Prim = Int | Double
type AllowedTypes = Prim :: (Prim, Prim) :: (Prim, Prim, Prim) :: End

// Replacing IntExpr & DoubleExpr with
final case class Primitive[As <: TypeList, A <: Prim](
  expr: A
)(implicit val ev: Prim IsElementOf As) extends Expr[As, Prim]


```

---

## My Allowed types (Note)

```scala

// Infact this is possible too
type AllowedTypes[A] = A :: (A, A) :: (A, A, A) :: End



```
---

## Helpers


```scala
def sum[A](
  a: Expr[AllowedTypes, A], 
  b: Expr[AllowedTypes, A]
)(implicit elem: A IsElementOf AllowedTypes) =
  Sum(a, b)


```

---

## Helpers


```scala

  def zip[A, B](
   a: Expr[AllowedTypes, A], 
   b: Expr[AllowedTypes, B]
  )(implicit ev: A IsElementOf AllowedTypes, ev2: B IsElementOf AllowedTypes) =
    Zip(a, b)

```

---

## Original program

```scala

  val myExpr =
    sum(IntExpr(1), IntExpr(2))

  val complexExpr =
    sum(zip(myExpr, myExpr), zip(IntExpr(3), IntExpr(4)))
```

---

## Compiler


```scala

  def compile[As <: TypeList, A](
   expr: Expr[As, A]
  )(implicit instances: Instances[Num, As]): A =
    expr match {
      case sum @ Expr.Sum(left, right) =>
        def add[B](a: B, b: B): Num[B] => B =
          _.add(a, b)

        instances.withInstance(
          add(compile(left), compile(right))
        )(sum.elem)
    }


```

---

# More practical example

```scala

  enum Query[A] {
    case ReadDb[A]() extends Query[A]
    case ReadCache[A]() extends Query[A]
    case ReadAPI[A]() extends Query[A]
    case Map[A, B](query: Query[B], f: A => B)(using val num: Num[A]) extends Query[B]
    case FlatMap[A, B](query: Query[B], f: A => Query[B]) extends Query[B]
  }


```

---

## Compiling the query

```scala

def compiler[As <: TypeList](query: Query[A])(implicit 
  ev1: Instances[SqlDecoder, As], 
  ev2: Instances[JsonDecoder, As]
): Task[A] = {
  case db @ ReadDb() => ev1.withInstance(...)(db.elem)
  case api @ ReadAPI() => ev2.withInstance(...)(api.elem)
}
```
---


Easily create captions using [inline] images/videos with text underneath.

---

# Plus:

- PDF export for printed handouts
- Speaker notes and rehearsal mode
- Switch theme and ratio on the fly
- Animated GIFs for cheap wins and LOLs :-)
