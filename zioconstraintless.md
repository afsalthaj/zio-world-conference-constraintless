footer: @afsal
slidenumbers: false

# Constraintless

---

## Famous Example

```scala

enum Expr[A] {
  case IntExpr(expr: Int) extends Expr[Int]
  case DoubleExpr(expr: Double) extends Expr[Double]
  case Sum[A](left: Expr[A], right: Expr[A]) extends Expr[A]
  case Zip[A, B](left: Expr[A], right: Expr[B]) extends Expr[(A, B)]
}

```
---
## Expr Usage

```scala
  val myExpr =
    Sum(IntExpr(1), IntExpr(2))

  val complexExpr =
    Sum(
      Zip(myExpr, myExpr), 
      Zip(IntExpr(3), IntExpr(4))
    )
```

---

## Compile

```scala
  def compile[A](expr: Expr[A]): A =
    expr match {
      case Expr.IntExpr(expr)    => expr
      case Expr.DoubleExpr(expr) => expr
      case Expr.Sum(left, right) => compile(left) + ??? // hmm, is compile(left) a tuple or ???
      case Expr.Zip(left, right) => (compile(left), compile(right))
    }
```

---

## Compile

The core of the problem is we are dealing with unknown types.

May be we can solve through typeclass

---
## Num typeclass

```scala
  trait Num[A] {
    def add(l: A, r: A): A
  }

  object Num {
    given Num[Int] = (l: Int, r: Int) => l + r
    given Num[Double] = (l: Double, r: Double) => l + r
    given numTuple[A, B](using ev1: Num[A], ev2: Num[B]): Num[(A, B)] = ...
  }

```

---

## Typeclass

```scala


 // Conceptually wrong
 def compile[A](expr: Expr[A])(implicit ev: Num[A]): A = 
    expr match {
      case Expr.IntExpr(expr) => expr
      case Expr.DoubleExpr(expr) => expr
      case Expr.Sum(left, right) => ev.add(compile(left)(ev), compile(right)(ev))
      case zip: Expr.Zip[a, b] => (compile(zip.left)(ev), compile(zip.right)(ev)) // Compile Error
    }

 compile(complexExpr)

```


---
 
## How about constraints at the point of definition ?
 

---

## Example

```scala

enum Expr[A] {
  case IntExpr(expr: Int) extends Expr[Int]
  case DoubleExpr(expr: Double) extends Expr[Double]
  case Sum[A](left: Expr[A], right: Expr[A])(using val ev1: Num[A]) extends Expr[A]
  case Zip[A, B](left: Expr[A], right: Expr[B]) extends Expr[(A, B)]
}

```

---

## And that compiles

```scala

  def compile[A](expr: Expr[A]): A =
    expr match {
      case Expr.IntExpr(expr) => expr
      case Expr.DoubleExpr(expr) => expr
      case sum @ Expr.Sum(left, right) => sum.ev1.add(compile(left), compile(right))
      case zip: Expr.Zip[a, b] => (compile(zip.left), compile(zip.right))
    }

```

---

## But ?

The language knows the executor details.
Num was really an executor detail.

---

## In other words

It should depend on the type of executor whether or not we need an instance of typeclass(es)

---

## Example

We never use the `Num` typeclass in this compiler

```scala
def compile[A](expr: Expr[A]): String =
  expr match {
    case Expr.IntExpr(expr) => s"${expr}"
    case Expr.DoubleExpr(expr) => s"${expr}"
    case Expr.Sum(left, right) => s"${compile(left)} + ${compile(right)}"
    case zip: Expr.Zip[a, b] => s"(${compile(zip.left)}, ${compile(zip.right)})"
}

println(compile(complexExpr))
// (1 + 2, 1 + 2) + (3, 4)

```
---


### http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf

> The key principle that underpins our idea is that implementation- specific constraints should be imposed at the point of use of a data type, not at the point of definition, 

>i.e. it embodies the established principle that an interface should be separated from its implementation(s).


---
## ZIO Constraintless 
 
Implementation based on a Haskell paper

```scala

http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf

(Will Jones, Tony Field & Tristan Allwood)
``` 



---
## Core idea

Essentially, we need to be able to define a compiler that depends on one or more type classes to do something with the types.


---

## Core idea


We need any types generated by the program at any point, to have an instance of a typeclass.


---

## Core idea

Zio-constraintless has `Instances[_, _]` 


`Instances[Num, As]` says that
all the types in `As <: TypeList` 
has an instance of `typeclass` `Num`


---

## Core idea

This implies, we need to have an idea of all possible types that the program generates.


---

## Summary of Constraintless

```scala

The TypeClass (Example: Num)
As <: TypeList (List of all types)
Instances[TypeClass, As] (auto resolved by library)
IsElementOf[A, As]       (auto resolved by library)


```

---
## Redefine our Expr

```scala

sealed trait Expr[As <: TypeList, A]


```
---
## Terms

```scala

  case IntExpr[As <: TypeList](expr: Int) extends Expr[As, Int]
  case DoubleExpr[As <: TypeList](expr: Double) extends Expr[As, Double]

```

---
## Terms


```scala

  // Interestingly
  case Sum[As <: TypeList, A](
   left: Expr[As, A], 
   right: Expr[As, A]
  )(using val elem: A IsElementOf As) extends Expr[As, A]
```


---
## My allowed types

```scala
  type AllowedTypes = Int :: Double :: (Int, Int) :: (Int, Double) :: End
```


---
## My allowed types

```scala
  type AllowedTypes = Int :: Double :: (Int, Int) :: (Int, Double) :: End
```

--- 
## My Allowed types (Note)

```scala
// In scala3, it gets even better
type Prim = Int | Double
type AllowedTypes = Prim :: (Prim, Prim) :: (Prim, Prim, Prim) :: End

// Replacing IntExpr & DoubleExpr with
case Primitive[As <: TypeList, A <: Prim](
  expr: A
)(using val elem: Prim IsElementOf As) extends Expr[As, Prim]


```

---

## My Allowed types (Note)

```scala

// Infact this is possible too
type AllowedTypes[A] = A :: (A, A) :: (A, A, A) :: End



```
---

## Helpers


```scala
def sum[A](
  a: Expr[AllowedTypes, A], 
  b: Expr[AllowedTypes, A]
)(implicit elem: A IsElementOf AllowedTypes) =
  Sum(a, b)


```

---

## Helpers


```scala

  def zip[A, B](
   a: Expr[AllowedTypes, A], 
   b: Expr[AllowedTypes, B]
  )(implicit ev: A IsElementOf AllowedTypes, ev2: B IsElementOf AllowedTypes) =
    Zip(a, b)

```

---

## Original program

```scala

  val myExpr =
    sum(IntExpr(1), IntExpr(2))

  val complexExpr =
    sum(zip(myExpr, myExpr), zip(IntExpr(3), IntExpr(4)))
```

---

## Compiler


```scala

  def compile[As <: TypeList, A](
   expr: Expr[As, A]
  )(implicit instances: Instances[Num, As]): A =
    expr match {
      case sum @ Expr.Sum(left, right) =>
        def add[B](a: B, b: B): Num[B] => B =
          _.add(a, b)

        instances.withInstance(
          add(compile(left), compile(right))
        )(sum.elem)
    }


```

---

# Another example

```scala

  enum Query[A] {
    case ReadDb[A]() extends Query[A]
    case ReadCache[A]() extends Query[A]
    case ReadAPI[A]() extends Query[A]
    case Map[A, B](query: Query[B], f: A => B)(using val num: Num[A]) extends Query[B]
    case FlatMap[A, B](query: Query[B], f: A => Query[B]) extends Query[B]
  }


```

---

## Compiling the query

```scala

def compiler[As <: TypeList](query: Query[A])(implicit 
  ev1: Instances[SqlDecoder, As], 
  ev2: Instances[JsonDecoder, As]
): Task[A] = {
  case db @ ReadDb() => ev1.withInstance(...)(db.elem)
  case api @ ReadAPI() => ev2.withInstance(...)(api.elem)
}
```
---

## When to use / examples

* Applicable for advanced libraries that rely on initial encoding.
  Currently used in ```zio-schema```
* Application codebase that deals with like execution plan and multiple datasources, and its read/write.
* Multi compiler languages, with complex logic to comprehend about types manually

---

## THANKS! 

@afsalt2 (twitter)
Afsal Thaj (Discord)

---